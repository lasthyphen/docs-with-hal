(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9042],{39538:function(e,n,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/guides/getting-started/tutorials/blockchain-components",function(){return s(77860)}])},77860:function(e,n,s){"use strict";s.r(n),s.d(n,{Page:function(){return r},meta:function(){return a}});var t=s(52322),i=s(3905),o=s(72499),a={id:"blockchain-components",title:"Blockchain Flow in Dijets",description:"Blockchain components and flow in Dijets",sidebar_label:"React"},r=function(e){var n=e.children;return(0,t.jsx)(o.Z,{meta:a,children:n})},c=r;function h(e){var n=Object.assign({p:"p",img:"img",h2:"h2",h3:"h3",a:"a",code:"code",ul:"ul",li:"li",strong:"strong"},(0,i.ah)(),e.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"/docs/img/blockchain-flow.png",alt:"Dijets Blockchain Flow"})}),"\n",(0,t.jsx)(n.h2,{id:"intro",children:"Intro"}),"\n",(0,t.jsx)(n.p,{children:"The Dijets network consists of 3 built-in blockchains: Value Chain, Utility Chain, and\nMethod Chain. The Value Chain is used to manage assets and uses the Dijets consensus\nprotocol. The Utility Chain is used to create and interact with smart contracts. The Method Chain is used to coordinate\nvalidators and stake and acts as the metadata chain for the network. A set of validators\nmakes up a Subnetwork. Subnetworks can validate 1 or more chains. It is a common\nmisconception that 1 Subnetwork = 1 chain and this is shown by the primary Subnetwork of\nDijets which is made up of the Value Chain, Utility Chain, and Method Chain."}),"\n",(0,t.jsx)(n.p,{children:"A node in the Dijets network can either be a validator or a non-validator. A\nvalidator stakes DJTX tokens and participates in consensus to earn rewards. A\nnon-validator does not participate in consensus or have any DJTX staked but can\nbe used as an API server. Both validators and non-validators need to have their\nown copy of the chain and need to know the current state of the network."}),"\n",(0,t.jsx)(n.p,{children:"Each blockchain on Dijets has several components: the virtual machine,\ndatabase, consensus engine, sender, and handler. These components help the chain\nrun smoothly. Blockchains also interact with the P2P layer and the chain router\nto send and receive messages."}),"\n",(0,t.jsx)(n.h2,{id:"peer-to-peer-p2p",children:"Peer-to-Peer (P2P)"}),"\n",(0,t.jsx)(n.h3,{id:"outbound-messages",children:"Outbound Messages"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/Dijets-Inc/dijetsnodego/blob/master/message/outbound_msg_builder.go",children:"The OutboundMsgBuilder interface"}),"\nspecifies methods that build messages of type ",(0,t.jsx)(n.code,{children:"OutboundMessage"}),". Nodes\ncommunicate to other nodes by sending ",(0,t.jsx)(n.code,{children:"OutboundMessage"})," messages."]}),"\n",(0,t.jsxs)(n.p,{children:["All messaging functions in ",(0,t.jsx)(n.code,{children:"OutboundMsgBuilder"})," can be categorized as follows:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Handshake"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Nodes need to be on a certain version before they can be accepted into the network."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"State Sync"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A new node can ask other nodes for the current state of the network. It only\nsyncs the required state for a specific block."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Bootstrapping"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Nodes can ask other nodes for blocks to build their own copy of the chain. A\nnode can fetch all blocks from the locally last accepted block to the\ncurrent last accepted block in the network."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Consensus"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Once a node is up to tip they can participate in consensus! During\nconsensus, a node conducts a poll to several different small random samples\nof the validator set. They can communicate decisions on whether or not they\nhave accepted/rejected a block."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"App"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"VMs communicate application-specific messages to other nodes through app\nmessages. A common example is mempool gossiping."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Currently, DijetsNodeGo implements its own message serialisation to communicate.\nIn the future, DijetsNodeGo will use protocol buffers to communicate."}),"\n",(0,t.jsx)(n.h3,{id:"network",children:"Network"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.a,{href:"https://github.com/Dijets-Inc/dijetsnodego/blob/master/network/network.go",children:"The networking\ninterface"}),"\nis shared across all chains. It implements functions from the ",(0,t.jsx)(n.code,{children:"ExternalSender"}),"\ninterface. The two functions it implements are ",(0,t.jsx)(n.code,{children:"Send"})," and ",(0,t.jsx)(n.code,{children:"Gossip"}),". ",(0,t.jsx)(n.code,{children:"Send"})," sends\na message of type ",(0,t.jsx)(n.code,{children:"OutboundMessage"})," to a specific set of nodes (specified by an\narray of ",(0,t.jsx)(n.code,{children:"NodeIDs"}),"). ",(0,t.jsx)(n.code,{children:"Gossip"})," sends a message of type ",(0,t.jsx)(n.code,{children:"OutboundMessage"})," to a\nrandom group of nodes in a Subnetwork (can be a validator or a non-validator).\nGossiping is used to push transactions across the network. The networking\nprotocol uses TLS to pass messages between peers."]}),"\n",(0,t.jsx)(n.p,{children:"Along with sending and gossiping, the networking library is also responsible for\nmaking connections and maintaining connections. Any node, either a validator or\nnon-validator, will attempt to connect to the primary network."}),"\n",(0,t.jsx)(n.h2,{id:"router",children:"Router"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.a,{href:"https://github.com/Dijets-Inc/dijetsnodego/blob/master/snow/networking/router/chain_router.go",children:["The\n",(0,t.jsx)(n.code,{children:"ChainRouter"})]}),"\nroutes all incoming messages to its respective blockchain using ",(0,t.jsx)(n.code,{children:"ChainID"}),". It\ndoes this by pushing all the messages onto the respective Chain handler\u2019s queue.\nThe ",(0,t.jsx)(n.code,{children:"ChainRouter"})," references all existing chains on the network such as the\nValue Chain, Utility Chain, Method Chain and possibly any other chain. The ",(0,t.jsx)(n.code,{children:"ChainRouter"}),"\nhandles timeouts as well. When sending messages on the P2P layer, timeouts are\nregistered on the sender and cleared on the ",(0,t.jsx)(n.code,{children:"ChainRouter"})," side when a response\nis received. If no response is received, then it triggers a timeout. Because\ntimeouts are handled on the ",(0,t.jsx)(n.code,{children:"ChainRouter"})," side, the handler is reliable.\nTimeouts are triggered when peers do not respond and the ",(0,t.jsx)(n.code,{children:"ChainRouter"})," will\nstill notify the handler of failure cases. The timeout manager within\n",(0,t.jsx)(n.code,{children:"ChainRouter"})," is also adaptive. If the network is experiencing long latencies,\ntimeouts will then be adjusted as well."]}),"\n",(0,t.jsx)(n.h2,{id:"handler",children:"Handler"}),"\n",(0,t.jsxs)(n.p,{children:["The main function of ",(0,t.jsxs)(n.a,{href:"https://github.com/Dijets-Inc/dijetsnodego/blob/master/snow/networking/handler/handler.go",children:["the\n",(0,t.jsx)(n.code,{children:"Handler"})]}),"\nis to pass messages from the network to the consensus engine. It receives these\nmessages from the ",(0,t.jsx)(n.code,{children:"ChainRouter"}),". It passes messages by pushing them onto a sync\nor Async queue (depends on message type). Messages are then popped from the\nqueue, parsed, and routed to the correct function in consensus engine. This can\nbe one of the following."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"State sync message (sync queue)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Bootstrapping message (sync queue)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Consensus message (sync queue)"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"App message (Async queue)"})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"sender",children:"Sender"}),"\n",(0,t.jsxs)(n.p,{children:["The main role of ",(0,t.jsxs)(n.a,{href:"https://github.com/Dijets-Inc/dijetsnodego/blob/master/snow/networking/sender/sender.go",children:["the\n",(0,t.jsx)(n.code,{children:"sender"})]}),"\nis to build and send outbound messages. It is actually a very thin wrapper\naround the normal networking code. The main difference here is that sender\nregisters timeouts and tells the router to expect a response message. The timer\nstarts on the sender side. If there is no response, sender will send a failed\nresponse to the router. If a node is repeatedly unresponsive, that node will get\nbenched and the sender will immediately start marking those messages as failed.\nIf a sufficient amount of network deems the node benched, it might not get\nrewards (as a validator)."]}),"\n",(0,t.jsx)(n.h2,{id:"consensus-engine",children:"Consensus Engine"}),"\n",(0,t.jsxs)(n.p,{children:["Consensus is defined as getting a group of distributed systems to agree on an\noutcome. In the case of the Dijets network, consensus is achieved when\nvalidators are in agreement with the state of the blockchain.\nDijets Consensus is a refined iteration of the HotStuff consensus protocol.\nThe engine is responsible for adding and proposing a new block to consensus,\nrepeatedly polling the network for decisions (accept/reject), and communicating\nthat decision to the ",(0,t.jsx)(n.code,{children:"Sender"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"blockchain-creation",children:"Blockchain Creation"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsxs)(n.a,{href:"https://github.com/Dijets-Inc/dijetsnodego/blob/master/chains/manager.go",children:["The\n",(0,t.jsx)(n.code,{children:"Manager"})]}),"\nis what kick-starts everything with regards to blockchain creation, starting with\nthe Method Chain. Once the Method Chain finishes bootstrapping, it will kickstart Utility Chain\nand Value Chain and any other chains. The Manager's job is not done yet, if a\ncreate-chain transaction is seen by a validator, a whole new process to create a\nchain will be started by the ",(0,t.jsx)(n.code,{children:"Manager"}),". This can happen dynamically, long after\nthe 3 chains in the Primary Network have been created and bootstrapped."]})]})}n.default=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return(0,t.jsx)(c,Object.assign({},e,{children:(0,t.jsx)(h,e)}))}}},function(e){e.O(0,[2331,2499,9774,2888,179],(function(){return n=39538,e(e.s=n);var n}));var n=e.O();_N_E=n}]);